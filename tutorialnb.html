<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Introduction &mdash; ChronoCluster 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="_static/nbsphinx-code-cells.css" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=2709fde1"></script>
        <script src="_static/doctools.js?v=9a2dae69"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Modules" href="modules.html" />
    <link rel="prev" title="Tutorial" href="tutorial.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            ChronoCluster
          </a>
              <div class="version">
                0.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="tutorial.html">Tutorial</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#Spacetime-Archaeology">Spacetime Archaeology</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Spacetime-Thinking">Spacetime Thinking</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Key-Terms-and-Definitions">Key Terms and Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Space-Time-Volume">Space-Time Volume</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Example:-Representing-a-Single-Archaeological-Site-in-Space-Time">Example: Representing a Single Archaeological Site in Space-Time</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Interpreting-the-Plot">Interpreting the Plot</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Understanding-the-Pipe-and-PPF">Understanding the Pipe and PPF</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Explanation-of-the-Plot">Explanation of the Plot</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#Representing-Spacetime-Points-in-ChronoCluster">Representing Spacetime Points in ChronoCluster</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#The-Point-Class">The Point Class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Calculating-Inclusion-Probabilities">Calculating Inclusion Probabilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Custom-ddelta-Probability-Class-in-ChronoCluster">Custom ddelta Probability Class in ChronoCluster</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Explanation-of-the-ddelta-Class">Explanation of the ddelta Class</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#Using-the-Point-Class-with-different-start/end-distributions">Using the Point Class with different start/end distributions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#Multiple-Points-in-ChronoCluster">Multiple Points in ChronoCluster</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Example:-Generating-and-Plotting-Random-Points">Example: Generating and Plotting Random Points</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id1">Explanation of the Plot</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#Pairwise-Distances-and-Clustering-Statistics-in-ChronoCluster">Pairwise Distances and Clustering Statistics in ChronoCluster</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Temporality-and-Chronological-Uncertainty">Temporality and Chronological Uncertainty</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Example:-Pairwise-Distances-with-Temporal-and-Chronological-Uncertainty">Example: Pairwise Distances with Temporal and Chronological Uncertainty</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Step-1:-Define-Time-Slices">Step 1: Define Time Slices</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Step-2:-Precompute-Inclusion-Probabilities">Step 2: Precompute Inclusion Probabilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Step-3:-Run-Monte-Carlo-Simulations">Step 3: Run Monte Carlo Simulations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Step-4:-Determine-Maximum-Distance">Step 4: Determine Maximum Distance</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Step-5:-Produce-Pairwise-Distances">Step 5: Produce Pairwise Distances</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Step-6:-Visualize-Clustering">Step 6: Visualize Clustering</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Interpreting-the-Clustering-Heatmap">Interpreting the Clustering Heatmap</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#Statistical-Significance-and-Complete-Spatial-Randomness">Statistical Significance and Complete Spatial Randomness</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Example:-Evaluating-Statistical-Significance-Against-CSR">Example: Evaluating Statistical Significance Against CSR</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Step-1:-Create-CSR-Data">Step 1: Create CSR Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Step-2.-Calculate-Pairwise-Distance-Density-for-CSR-data">Step 2. Calculate Pairwise Distance Density for CSR data</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Step-3:-Calculate-P-Values-for-Density-Differences">Step 3: Calculate P-Values for Density Differences</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Step-4:-Plot-the-Heatmap-of-P-Values">Step 4: Plot the Heatmap of P-Values</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Explanation-of-the-Code">Explanation of the Code</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Interpretation-of-the-Heatmap">Interpretation of the Heatmap</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#Other-ChronoCluster-Clustering-Statistics">Other ChronoCluster Clustering Statistics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Example-Code-for-Ripley's-K,-L,-and-G-Functions">Example Code for Ripley’s K, L, and G Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Explanation">Explanation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="modules.html">Modules</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">ChronoCluster</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="tutorial.html">Tutorial</a></li>
      <li class="breadcrumb-item active">Introduction</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/tutorialnb.ipynb.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="Introduction">
<h1>Introduction<a class="headerlink" href="#Introduction" title="Link to this heading"></a></h1>
<p>Understanding the spatial distribution of archaeological sites and artifacts is a fundamental aspect of studying past human activities. However, a significant challenge arises when considering the temporality and chronological uncertainty associated with these points. Not all points we observe in the archaeological record were necessarily contemporaneous, and our chronometric tools for dating them often have significant uncertainties. This complicates traditional point pattern analyses, which
typically assume that all points are fixed in both space and time.</p>
<p>ChronoCluster is a Python package designed to address this challenge. It provides tools for analyzing spatial point patterns with temporality and chronological uncertainty, incorporating methods like Ripley’s K function and point-wise distance distributions to account for these factors. By allowing for the integration of temporal distributions and uncertainties into spatial analyses, ChronoCluster helps researchers obtain more accurate and meaningful insights from archaeological (and, for that
matter, historical and even palaeoclimatic) point data.</p>
<p>Key features of ChronoCluster include:</p>
<ul class="simple">
<li><p>Visualization tools for spatial point patterns, including the ability to represent temporal distributions;</p></li>
<li><p>Clustering analysis using Ripley’s K, L, and G functions, accounting for temporality (change over time) and chronological uncertainty;</p></li>
<li><p>Pairwise distance distributions accounting for both temporality and chronological uncertainty; and</p></li>
<li><p>Comparison of observed patterns to CSR (Complete Spatial Randomness) baselines to determine significant clustering or dispersion patterns.</p></li>
</ul>
<p>In this workbook, you’ll be introduced to the package, its paradigm, its terminology, and its key functions and features.</p>
</section>
<section id="Spacetime-Archaeology">
<h1>Spacetime Archaeology<a class="headerlink" href="#Spacetime-Archaeology" title="Link to this heading"></a></h1>
<p>In spatial analysis, a point represents a location of interest within a given study area. In archaeology, points often represent the locations of sites or artifacts. A point pattern is a collection of such points, which can be analyzed to reveal spatial relationships and patterns, such as clustering or dispersion.</p>
<p>Traditional point pattern analyses assume that all points are fixed in both space and time. However, in archaeology, points have temporality—each site or artifact existed at a specific time, and our ability to date these points often comes with significant uncertainties. This complicates analyses as it requires considering the temporal existence and chronological uncertainty of these points.</p>
<section id="Spacetime-Thinking">
<h2>Spacetime Thinking<a class="headerlink" href="#Spacetime-Thinking" title="Link to this heading"></a></h2>
<p>To better analyze archaeological points, we can adopt a spacetime perspective. In this framework, each point has not only spatial coordinates (x, y) but also a temporal coordinate (z), representing its existence over time. This approach allows us to visualize and analyze the temporal dimension of archaeological data, considering when each point existed and the uncertainties associated with its dating.</p>
</section>
<section id="Key-Terms-and-Definitions">
<h2>Key Terms and Definitions<a class="headerlink" href="#Key-Terms-and-Definitions" title="Link to this heading"></a></h2>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Term</p></th>
<th class="head"><p>Definition</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Point</strong></p></td>
<td><p>A location of interest within a study area, represented by spatial coordinates (x, y).</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Point Pattern</strong></p></td>
<td><p>A collection of points analyzed to reveal spatial relationships and patterns.</p></td>
</tr>
<tr class="row-even"><td><p><strong>Temporality</strong></p></td>
<td><p>The characteristic of a point having a specific existence in time.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Chronological Uncertainty</strong></p></td>
<td><p>The uncertainty associated with the dating of a point.</p></td>
</tr>
<tr class="row-even"><td><p><strong>Space-Time Volume</strong></p></td>
<td><p>A conceptual model with spatial dimensions (x, y) and a temporal dimension (z).</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Temporal Distribution</strong></p></td>
<td><p>A probability distribution representing the possible times during which a point existed.</p></td>
</tr>
<tr class="row-even"><td><p><strong>World Line</strong></p></td>
<td><p>In physics, the path that an object traces in 4-dimensional spacetime. Here, it refers to the temporal existence of a point in the space-time volume.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Palimpsest</strong></p></td>
<td><p>An archaeological term commonly used to describe the overlap of multiple temporal layers of human activity within the same spatial location.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="Space-Time-Volume">
<h2>Space-Time Volume<a class="headerlink" href="#Space-Time-Volume" title="Link to this heading"></a></h2>
<p>A <strong>space-Time Volume</strong> (STV) refers to a conceptual model where the x and y axes represent spatial dimensions and the z axis represents the temporal dimension. Each archaeological site or artifact can be thought of as existing within this volume, with a certain temporal duration and spatial extent.</p>
</section>
<section id="Example:-Representing-a-Single-Archaeological-Site-in-Space-Time">
<h2>Example: Representing a Single Archaeological Site in Space-Time<a class="headerlink" href="#Example:-Representing-a-Single-Archaeological-Site-in-Space-Time" title="Link to this heading"></a></h2>
<p>Let’s consider an example where we have an archaeological site represented as a single point. This site has a known spatial location but uncertain temporal existence. We can model its temporal presence using probability distributions.</p>
<p>In a plot below, we’ll illustrate:</p>
<ul class="simple">
<li><p>The spatial location of the site on the x-y plane.</p></li>
<li><p>The temporal presence of the site as a vertical pipe in the space-time volume, where the z-axis represents time.</p></li>
<li><p>A <strong>time slice</strong> indicating a specific moment in time, showing the likelihood of the site’s presence during that period.</p></li>
</ul>
<p>We will need a number of libraries:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Analysis</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">chronocluster.data.simdata</span> <span class="kn">import</span> <span class="n">generate_random_points</span>
<span class="kn">from</span> <span class="nn">chronocluster</span> <span class="kn">import</span> <span class="n">clustering</span>
<span class="kn">from</span> <span class="nn">chronocluster.utils</span> <span class="kn">import</span> <span class="n">clustering_heatmap</span><span class="p">,</span> <span class="n">pdiff_heatmap</span><span class="p">,</span> <span class="n">plot_mc_points</span><span class="p">,</span> <span class="n">get_box</span><span class="p">,</span> <span class="n">ddelta</span><span class="p">,</span> <span class="n">chrono_plot</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">norm</span>

<span class="c1"># plotting</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
</pre></div>
</div>
</div>
<p>Then, we need to generate a random point using some ChronoCluster functions and probability distributions (those will be explained further down) just to illustrate some key ideas:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># define cluster distributions</span>
<span class="n">cluster_center</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">cluster_std</span> <span class="o">=</span> <span class="mf">1.0</span>

<span class="c1"># randomly select point coords</span>
<span class="n">x_coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">cluster_center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">scale</span><span class="o">=</span><span class="n">cluster_std</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">y_coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">cluster_center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">scale</span><span class="o">=</span><span class="n">cluster_std</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="n">start_age_mean</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">start_age_err</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">end_age_mean</span> <span class="o">=</span> <span class="mi">1200</span>
<span class="n">end_age_err</span> <span class="o">=</span> <span class="mi">50</span>

<span class="c1"># create random start and end ages with uncertainty</span>
<span class="n">start_dist</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">start_age_mean</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">start_age_err</span><span class="p">)</span>
<span class="n">end_dist</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">end_age_mean</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">end_age_err</span><span class="p">)</span>

<span class="c1"># finally, generate random point</span>
<span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">clustering</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">x_coord</span><span class="p">,</span>
              <span class="n">y</span> <span class="o">=</span> <span class="n">y_coord</span><span class="p">,</span>
              <span class="n">start_distribution</span> <span class="o">=</span> <span class="n">start_dist</span><span class="p">,</span>
              <span class="n">end_distribution</span> <span class="o">=</span> <span class="n">end_dist</span><span class="p">)]</span>
</pre></div>
</div>
</div>
<p>And, lastly, we can call a ChronoCluster plotting function to plot the point in a spacetime volume:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Custom styling parameters</span>
<span class="n">style_params</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;start_mean_color&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># Do not plot start mean points</span>
    <span class="s1">&#39;end_mean_color&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="c1"># Do not plot end mean points</span>
    <span class="s1">&#39;mean_point_size&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="s1">&#39;cylinder_color&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">),</span>  <span class="c1"># Dark grey</span>
    <span class="s1">&#39;ppf_limits&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">),</span>  <span class="c1"># Use different ppf limits</span>
    <span class="s1">&#39;shadow_color&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">),</span>  <span class="c1"># grey</span>
    <span class="s1">&#39;shadow_size&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="s1">&#39;time_slice_color&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span>  <span class="c1"># Grey</span>
    <span class="s1">&#39;time_slice_alpha&#39;</span><span class="p">:</span> <span class="mf">0.3</span><span class="p">,</span>
    <span class="s1">&#39;time_slice_point_color&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>  <span class="c1"># Black</span>
<span class="p">}</span>

<span class="c1"># Plot the points using the chrono_plot function with custom styling and a time slice plane</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">chrono_plot</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">style_params</span><span class="o">=</span><span class="n">style_params</span><span class="p">,</span> <span class="n">time_slice</span><span class="o">=</span><span class="mi">1100</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_box_aspect</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">zoom</span><span class="o">=</span><span class="mf">0.85</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/tutorialnb_6_0.png" src="_images/tutorialnb_6_0.png" />
</div>
</div>
</section>
<section id="Interpreting-the-Plot">
<h2>Interpreting the Plot<a class="headerlink" href="#Interpreting-the-Plot" title="Link to this heading"></a></h2>
<p>In this example, we generated a single point with spatial coordinates and temporal distributions for its start and end dates. The plot visualizes the point’s spatial location, its temporal presence, and its likelihood of being present at a specified time slice. This visual representation helps to introduce the concept of analyzing archaeological point patterns with both temporality and chronological uncertainty.</p>
<ul class="simple">
<li><p>Spatial Location: The x and y coordinates represent the geographical location of the archaeological site.</p></li>
<li><p>Temporal Presence: The vertical gray pipe represents the temporal presence of the site within the space-time volume. This is determined by the probability distributions for the start and end dates.</p></li>
<li><p>Time Slice: The grey, semi-transparent plane represents a specific time slice (in this case, at 1100 years). If a point’s world line intersects the plane, the intersection is represented by a black dot (time slice point) on the plane, indicating that the point is ‘present’ in the pattern at that time.</p></li>
</ul>
</section>
<section id="Understanding-the-Pipe-and-PPF">
<h2>Understanding the Pipe and PPF<a class="headerlink" href="#Understanding-the-Pipe-and-PPF" title="Link to this heading"></a></h2>
<p>The pipe illustrates the site’s temporal persistence within the space-time volume. The ends of the pipe are determined by the start and end distributions’ percent point functions (PPF). The PPF, also known as the inverse cumulative distribution function (CDF), defines the specific points in time at which the cumulative probability reaches a certain value. For instance, a PPF value at the 1st percentile (PPF(0.01)) and the 99th percentile (PPF(0.99)) gives us a range within which we are 98%
confident the event occurred.</p>
<p>To make this clearer, let’s visualize the start and end distributions of a single point and the resulting world line in a 2D plot focused only on time and not space. The horizontal axis will represent the time duration during which the point exists in the space-time volume.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define the start and end distributions</span>
<span class="n">start_age_mean</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">start_age_err</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">end_age_mean</span> <span class="o">=</span> <span class="mi">1200</span>
<span class="n">end_age_err</span> <span class="o">=</span> <span class="mi">50</span>

<span class="n">start_dist</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">start_age_mean</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">start_age_err</span><span class="p">)</span>
<span class="n">end_dist</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">end_age_mean</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">end_age_err</span><span class="p">)</span>

<span class="c1"># Generate a range of x values (time)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">1400</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>

<span class="c1"># Plot the probability density functions (PDFs)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">start_dist</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Start Distribution&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">end_dist</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;End Distribution&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>

<span class="c1"># Determine the PPF limits (1st and 99th percentiles)</span>
<span class="n">start_ppf</span> <span class="o">=</span> <span class="p">(</span><span class="n">start_dist</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.01</span><span class="p">),</span> <span class="n">start_dist</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.99</span><span class="p">))</span>
<span class="n">end_ppf</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_dist</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.01</span><span class="p">),</span> <span class="n">end_dist</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.99</span><span class="p">))</span>

<span class="c1"># Plot horizontal line (world line) between start and end PPFs</span>
<span class="n">world_line_y</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.002</span>
<span class="n">plt</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="n">world_line_y</span><span class="p">,</span> <span class="n">start_ppf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end_ppf</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Temporal Presence (World Line)&#39;</span><span class="p">)</span>

<span class="c1"># Annotate the PPF limits</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">start_ppf</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">world_line_y</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">end_ppf</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">world_line_y</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Add labels and legend</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Probability Density&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper right&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Temporal Distributions and World Line&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.005</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">start_dist</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">end_dist</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>

<span class="c1"># Set y-axis limits and ticks to avoid negative values</span>
<span class="n">max_density</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">start_dist</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">end_dist</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.005</span><span class="p">,</span> <span class="n">max_density</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.000</span><span class="p">,</span> <span class="n">max_density</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">)</span> <span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/tutorialnb_8_0.png" src="_images/tutorialnb_8_0.png" />
</div>
</div>
<section id="Explanation-of-the-Plot">
<h3>Explanation of the Plot<a class="headerlink" href="#Explanation-of-the-Plot" title="Link to this heading"></a></h3>
<p>In the plot:</p>
<ul class="simple">
<li><p>The blue curve represents the start distribution, showing the probability of the site’s presence starting at different times.</p></li>
<li><p>The red curve represents the end distribution, showing the probability of the site’s presence ending at different times.</p></li>
<li><p>The gray horizontal line near the x-axis represents the world line, indicating the temporal persistence of the site within the space-time volume.</p></li>
<li><p>The blue dot marks the 1st percentiles of the start distribution.</p></li>
<li><p>The red dot marks the 99th percentiles of the end distribution.</p></li>
</ul>
<p>This plot helps visualize how the temporal distributions of a point define its temporal presence and how we can model the uncertainties associated with dating the point. The pipe in the 3D plot from before extends vertically between the PPF limits of the start and end distributions, representing the point’s presence over time.</p>
<p>The chrono_plot function makes use of these concepts to visualize the temporal persistence of points in the space-time volume. The function takes the spatial coordinates (x, y) and the temporal distributions (start and end) of points and generates a 3D plot with:</p>
<ul class="simple">
<li><p>Pipes representing the temporal presence of each point.</p></li>
<li><p>Time slice planes to visualize the presence of points at specific moments in time.</p></li>
</ul>
</section>
</section>
</section>
<section id="Representing-Spacetime-Points-in-ChronoCluster">
<h1>Representing Spacetime Points in ChronoCluster<a class="headerlink" href="#Representing-Spacetime-Points-in-ChronoCluster" title="Link to this heading"></a></h1>
<p>With these visualizations and spacetime concepts in mind, we can look at how ChronoCluster represents points in spacetime internally. The package uses a <strong>Point</strong> class. This class encapsulates both the spatial coordinates and the temporal distributions that describe when the point exists. Below, we will explain the Point class, its attributes, and key methods such as calculating inclusion probabilities for time slices.</p>
<section id="The-Point-Class">
<h2>The Point Class<a class="headerlink" href="#The-Point-Class" title="Link to this heading"></a></h2>
<p>The Point class is designed to hold information about a single point in spacetime, including its spatial location and the temporal distributions that define its presence over time.</p>
<p>Attributes:</p>
<ul class="simple">
<li><p>x (float): The x-coordinate of the point.</p></li>
<li><p>y (float): The y-coordinate of the point.</p></li>
<li><p>start_distribution (scipy.stats.rv_continuous): The probability distribution for the start date.</p></li>
<li><p>end_distribution (scipy.stats.rv_continuous): The probability distribution for the end date.</p></li>
</ul>
<p>Key Methods:</p>
<ol class="arabic simple">
<li><p>Initialization (<code class="docutils literal notranslate"><span class="pre">__init__</span></code> method):</p></li>
</ol>
<p>The constructor initializes a new Point instance with given coordinates and distributions.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">start_distribution</span><span class="p">,</span> <span class="n">end_distribution</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">start_distribution</span> <span class="o">=</span> <span class="n">start_distribution</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">end_distribution</span> <span class="o">=</span> <span class="n">end_distribution</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Temporal consistency check...&quot;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_check_distributions</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>Checking Distributions (<code class="docutils literal notranslate"><span class="pre">_check_distributions</span></code> method):</p></li>
</ol>
<p>This private method checks the temporal consistency of the start and end distributions.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_check_distributions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
    <span class="n">overlap_ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_overlap_ratio</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">overlap_ratio</span> <span class="o">&gt;</span> <span class="mf">0.25</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Significant overlap between start and end distributions. Overlap ratio: </span><span class="si">{</span><span class="n">overlap_ratio</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">start_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_distribution</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">end_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_distribution</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">end_mean</span> <span class="o">&lt;</span> <span class="n">start_mean</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: End date distribution mean (</span><span class="si">{</span><span class="n">end_mean</span><span class="si">}</span><span class="s2">) is earlier than start date distribution mean (</span><span class="si">{</span><span class="n">start_mean</span><span class="si">}</span><span class="s2">). Possible data error.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li><p>Calculating Overlap Ratio (<code class="docutils literal notranslate"><span class="pre">_calculate_overlap_ratio</span></code> method):</p></li>
</ol>
<p>This private method calculates the overlap ratio between the start and end distributions.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_calculate_overlap_ratio</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">range_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_distribution</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.01</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_distribution</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.01</span><span class="p">))</span>
    <span class="n">range_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_distribution</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.99</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_distribution</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.99</span><span class="p">))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">range_min</span><span class="p">,</span> <span class="n">range_max</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="n">start_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_distribution</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">end_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_distribution</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">overlap_pdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">start_pdf</span><span class="p">,</span> <span class="n">end_pdf</span><span class="p">)</span>
    <span class="n">overlap_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">overlap_pdf</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">total_area_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">start_pdf</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">total_area_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">end_pdf</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">combined_area</span> <span class="o">=</span> <span class="n">total_area_start</span> <span class="o">+</span> <span class="n">total_area_end</span>
    <span class="k">if</span> <span class="n">combined_area</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Sum of density integrals is zero! Check that start and end dates are present and, if constant, not identical.&quot;</span><span class="p">)</span>
        <span class="n">overlap_ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">overlap_ratio</span> <span class="o">=</span> <span class="n">overlap_area</span> <span class="o">/</span> <span class="n">combined_area</span>
    <span class="k">return</span> <span class="n">overlap_ratio</span>
</pre></div>
</div>
<ol class="arabic simple" start="4">
<li><p>Calculating Inclusion Probability (<code class="docutils literal notranslate"><span class="pre">calculate_inclusion_probability</span></code> method):</p></li>
</ol>
<p>This method calculates the inclusion probability of the point for a given time slice.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">calculate_inclusion_probability</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_slice</span><span class="p">):</span>
    <span class="n">start_prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_distribution</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">time_slice</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">start_prob</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># If start probability is zero or negative</span>
        <span class="k">return</span> <span class="mf">0.0</span>
    <span class="n">end_prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_distribution</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">time_slice</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">start_prob</span> <span class="o">*</span> <span class="n">end_prob</span>
</pre></div>
</div>
</section>
<section id="Calculating-Inclusion-Probabilities">
<h2>Calculating Inclusion Probabilities<a class="headerlink" href="#Calculating-Inclusion-Probabilities" title="Link to this heading"></a></h2>
<p>The last of these highlighted methods is a key concept in ChronoCluster. Inclusion probability – the likelihood that a point is present in the pattern at a specific time slice – is used throughout the package for analyses and plotting. The inclusion probability for a given point is calculated using the cumulative distribution function (CDF) of the start distribution and the survival function (SF) of the end distribution for that point.</p>
<ul class="simple">
<li><p>Cumulative Distribution Function (CDF): The CDF of a distribution gives the probability that a random variable is less than or equal to a certain value. For a given time slice <span class="math notranslate nohighlight">\(t\)</span>, the CDF of the start distribution <span class="math notranslate nohighlight">\(F_{start}(t)\)</span> represents the probability that the point’s existence has started by that time.</p></li>
<li><p>Survival Function (SF): The survival function, also known as the complementary cumulative distribution function, gives the probability that a random variable is greater than a certain value. For a given time slice <span class="math notranslate nohighlight">\(t\)</span>, the SF of the end distribution <span class="math notranslate nohighlight">\(S_{end}(t)\)</span> represents the probability that the point’s existence has not ended by that time.</p></li>
</ul>
<p>The inclusion probability, $ P_{<span class="math">\text{inclusion}</span>} $, at a time slice, $ t $, is given by:</p>
<div class="math notranslate nohighlight">
\[P_{\text{inclusion}}(t) = F_{\text{start}}(t) \times S_{\text{end}}(t)\]</div>
<p>Where:</p>
<ul class="simple">
<li><p>$ F_{<span class="math">\text{start}</span>}(t) $ is the CDF of the start distribution at time $ t $</p></li>
<li><p>$ S_{<span class="math">\text{end}</span>}(t) $ is the SF of the end distribution at time $ t $</p></li>
</ul>
</section>
<section id="Custom-ddelta-Probability-Class-in-ChronoCluster">
<h2>Custom ddelta Probability Class in ChronoCluster<a class="headerlink" href="#Custom-ddelta-Probability-Class-in-ChronoCluster" title="Link to this heading"></a></h2>
<p>ChronoCluster allows for flexibility in representing the temporal distributions of points. A point can have different start and end distributions, which can belong to different families of probability distributions. This flexibility is essential for modeling various types of temporal uncertainties and certainties in archaeological data.</p>
<p>One of the custom probability distribution classes used in ChronoCluster is the <code class="docutils literal notranslate"><span class="pre">ddelta</span></code> class. This class represents a Dirac delta distribution, which is useful for encoding historical information where we have no uncertainty about the start or end times of a point. The ddirac class inherits from scipy.stats.rv_continuous and approximates the Dirac delta function. This distribution is characterized by a single value dd—representing a fixed time—and it is used when we are certain about the
start or end time of a point, as we might be with historical records of site founding or abandonment times, for example.</p>
<p>Here is the implementation of the ddirac class in ChronoCluster:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ddelta</span><span class="p">(</span><span class="n">rv_continuous</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Probability functions approximating the Dirac Delta&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ddelta&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">badvalue</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xtol</span> <span class="o">=</span> <span class="mf">1e-14</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moment_type</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numargs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vecentropy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entropy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generic_moment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_moment</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Probability density function&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cumulative distribution function&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="k">else</span> <span class="mf">0.0</span>

    <span class="k">def</span> <span class="nf">_sf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Survival function&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_ppf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Percent point function (inverse of cdf)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span>

    <span class="k">def</span> <span class="nf">_rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Random variates&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mean of the distribution&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span>

    <span class="k">def</span> <span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Variance of the distribution&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">0.0</span>

    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Standard deviation of the distribution&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">0.0</span>

    <span class="k">def</span> <span class="nf">_entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Entropy of the distribution&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">0.0</span>

    <span class="k">def</span> <span class="nf">_moment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;nth moment of the distribution&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">var</span><span class="p">()</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
</pre></div>
</div>
<section id="Explanation-of-the-ddelta-Class">
<h3>Explanation of the ddelta Class<a class="headerlink" href="#Explanation-of-the-ddelta-Class" title="Link to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">ddelta</span></code> class represents a distribution where all the probability mass is concentrated at a single point, <code class="docutils literal notranslate"><span class="pre">d</span></code>. This is useful for encoding certainty about the timing of an event.</p>
<ul class="simple">
<li><p>Probability Density Function (PDF): The _pdf method returns infinity at <span class="math notranslate nohighlight">\(d\)</span> and zero elsewhere, approximating the Dirac delta function.</p></li>
<li><p>Cumulative Distribution Function (CDF): The _cdf method returns 1 for any value greater than or equal to <span class="math notranslate nohighlight">\(d\)</span> and <span class="math notranslate nohighlight">\(0\)</span> otherwise.</p></li>
<li><p>Survival Function (SF): The _sf method is the complement of the CDF, returning 1 minus the CDF.</p></li>
<li><p>Percent Point Function (PPF): The _ppf method returns dd, indicating the exact point at which the probability mass is concentrated.</p></li>
<li><p>Random Variates (RVS): The _rvs method generates random variates, which are always <span class="math notranslate nohighlight">\(d\)</span>.</p></li>
<li><p>Mean and Variance: The mean method returns <span class="math notranslate nohighlight">\(d\)</span>, and the var method returns 0, indicating no variability.</p></li>
</ul>
<p>For more information on the Dirac Delta function, you can refer to the following resources:</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Dirac_delta_function">Wikipedia: Dirac Delta Function</a></p>
<p><a class="reference external" href="https://reference.wolfram.com/language/ref/DiracDelta.html">Wolfram MathWorld: Dirac Delta Function</a></p>
</section>
</section>
<section id="Using-the-Point-Class-with-different-start/end-distributions">
<h2>Using the Point Class with different start/end distributions<a class="headerlink" href="#Using-the-Point-Class-with-different-start/end-distributions" title="Link to this heading"></a></h2>
<p>The ChronoCluster Point class (and relevant analyses) are intended to be flexible enough to account for points that have different start and end date/time distributions, as noted earlier. You can specify different distributions when you create a <code class="docutils literal notranslate"><span class="pre">Point</span></code> object by passing distribution objects that inherit from <code class="docutils literal notranslate"><span class="pre">scipy.stats.rv_continuous</span></code> (constinuous distribution objects). At the moment, though, Chronocluster’s data i/o functions (<code class="docutils literal notranslate"><span class="pre">chronocluster.data</span></code> module) only supports Gaussian
(<code class="docutils literal notranslate"><span class="pre">norm</span></code>), Uniform (<code class="docutils literal notranslate"><span class="pre">unif</span></code>) constant (<code class="docutils literal notranslate"><span class="pre">ddelta</span></code>) distributions. But, other functions and the <code class="docutils literal notranslate"><span class="pre">Point</span></code> class can take any valid distribution that has <code class="docutils literal notranslate"><span class="pre">.pdf</span></code>, <code class="docutils literal notranslate"><span class="pre">.cdf</span></code>, <code class="docutils literal notranslate"><span class="pre">._sf</span></code>, <code class="docutils literal notranslate"><span class="pre">.ppf</span></code>, and <code class="docutils literal notranslate"><span class="pre">.rvs</span></code> methods that return mathematically correct values.</p>
<p>In the following example, we will create a <code class="docutils literal notranslate"><span class="pre">Point</span></code> object with: - A normal distribution for the start time, representing some uncertainty. - A <code class="docutils literal notranslate"><span class="pre">ddelta</span></code> distribution for the end time, indicating that the end time is known exactly.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">point</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
                         <span class="n">y</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
                         <span class="n">start_distribution</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">50</span><span class="p">),</span>
                         <span class="n">end_distribution</span> <span class="o">=</span> <span class="n">ddelta</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">1200</span><span class="p">))</span>

<span class="c1"># Display the point&#39;s attributes</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Point Coordinates: (</span><span class="si">{</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Start Distribution: Mean = </span><span class="si">{</span><span class="n">point</span><span class="o">.</span><span class="n">start_distribution</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="si">}</span><span class="s2">, Std = </span><span class="si">{</span><span class="n">point</span><span class="o">.</span><span class="n">start_distribution</span><span class="o">.</span><span class="n">std</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;End Distribution: Mean = </span><span class="si">{</span><span class="n">point</span><span class="o">.</span><span class="n">end_distribution</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="si">}</span><span class="s2">, Std = </span><span class="si">{</span><span class="n">point</span><span class="o">.</span><span class="n">end_distribution</span><span class="o">.</span><span class="n">std</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># And show the tidy in-line printing method for the Point class</span>
<span class="nb">print</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Point Coordinates: (10, 10)
Start Distribution: Mean = 1000.0, Std = 50.0
End Distribution: Mean = 1200, Std = 0.0
Point(x=10, y=10, start_distribution=norm(loc=1000.0, scale=50.0), end_distribution=ddelta(d=1200))
</pre></div></div>
</div>
</section>
</section>
<section id="Multiple-Points-in-ChronoCluster">
<h1>Multiple Points in ChronoCluster<a class="headerlink" href="#Multiple-Points-in-ChronoCluster" title="Link to this heading"></a></h1>
<p>To illustrate the capabilities of ChronoCluster in handling multiple points with varying temporal distributions, we can generate a set of random points. Each point will have its own start and end distributions, representing different durations of presence in the STV.</p>
<p>We will use the generate_random_points function to create these points. This function allows us to define cluster distributions, start and end date models, and uncertainties, and then generate a specified number of points based on these parameters. The generate_random_points Function</p>
<p>The generate_random_points function generates random points based on specified spatial and temporal distributions. Here’s a brief overview of its parameters:</p>
<ul class="simple">
<li><p>num_points (int): The number of points to generate.</p></li>
<li><p>cluster_centers (list of tuples): The centers of the clusters around which points are generated.</p></li>
<li><p>cluster_stds (list of floats): The standard deviations of the clusters.</p></li>
<li><p>start_type (str): The type of distribution for the start dates (e.g., ‘norm’ for normal distribution).</p></li>
<li><p>start_hyperparams (list): The hyperparameters for the start date distribution.</p></li>
<li><p>end_type (str): The type of distribution for the end dates (e.g., ‘constant’ for a fixed end date).</p></li>
<li><p>end_hyperparams (list): The hyperparameters for the end date distribution.</p></li>
</ul>
<p>Using this function, we can generate points that are clustered in space and have varying degrees of temporal uncertainty.</p>
<section id="Example:-Generating-and-Plotting-Random-Points">
<h2>Example: Generating and Plotting Random Points<a class="headerlink" href="#Example:-Generating-and-Plotting-Random-Points" title="Link to this heading"></a></h2>
<p>In the following example, we generate 40 random points divided into two clusters. The points have different start and end date distributions, demonstrating the flexibility of ChronoCluster.</p>
<p>Code Pipeline:</p>
<ol class="arabic simple">
<li><p>Define Cluster Distributions: We specify the centers and standard deviations for two clusters.</p></li>
<li><p>Create Start and End Age Distributions: We define different models and uncertainties for the start and end dates.</p></li>
<li><p>Generate Random Points: We use the generate_random_points function to create 40 points, with 20 points in each temporal distribution scenario.</p></li>
<li><p>Custom Styling: We define custom styling parameters for the plot.</p></li>
<li><p>Plot the Points: We use the chrono_plot function to visualize the points in the space-time volume.</p></li>
</ol>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># define cluster distributions</span>
<span class="n">cluster_centers</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">)]</span>
<span class="n">cluster_stds</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>

<span class="c1"># create random start and end ages with uncertainty for each point</span>
<span class="c1"># define dating models and uncertainties</span>
<span class="n">start_type</span> <span class="o">=</span> <span class="s1">&#39;norm&#39;</span>
<span class="n">start_hyperparams</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>
<span class="n">end_type</span> <span class="o">=</span> <span class="s1">&#39;constant&#39;</span>
<span class="n">end_hyperparams</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1700</span><span class="p">]</span>

<span class="c1"># finally, generate 100 random points using the above models</span>
<span class="n">points</span> <span class="o">=</span> <span class="n">generate_random_points</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span>
                                <span class="n">cluster_centers</span><span class="p">,</span>
                                <span class="n">cluster_stds</span><span class="p">,</span>
                                <span class="n">start_type</span><span class="p">,</span>
                                <span class="n">start_hyperparams</span><span class="p">,</span>
                                <span class="n">end_type</span><span class="p">,</span>
                                <span class="n">end_hyperparams</span><span class="p">)</span>

<span class="c1"># Custom styling parameters</span>
<span class="n">style_params</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;start_mean_color&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># Do not plot start mean points</span>
    <span class="s1">&#39;end_mean_color&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="c1"># Do not plot end mean points</span>
    <span class="s1">&#39;mean_point_size&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="s1">&#39;cylinder_color&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">),</span>  <span class="c1"># Dark grey</span>
    <span class="s1">&#39;ppf_limits&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">),</span>  <span class="c1"># Use different ppf limits</span>
    <span class="s1">&#39;shadow_color&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">),</span>  <span class="c1"># grey</span>
    <span class="s1">&#39;shadow_size&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="s1">&#39;time_slice_color&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span>  <span class="c1"># Grey</span>
    <span class="s1">&#39;time_slice_alpha&#39;</span><span class="p">:</span> <span class="mf">0.3</span><span class="p">,</span>
    <span class="s1">&#39;time_slice_point_color&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>  <span class="c1"># Black</span>
<span class="p">}</span>

<span class="c1"># Plot the points using the chrono_plot function with custom styling and a time slice plane</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">chrono_plot</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">style_params</span><span class="o">=</span><span class="n">style_params</span><span class="p">,</span> <span class="n">time_slice</span><span class="o">=</span><span class="mi">1500</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_box_aspect</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">zoom</span><span class="o">=</span><span class="mf">0.85</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/tutorialnb_16_0.png" src="_images/tutorialnb_16_0.png" />
</div>
</div>
</section>
<section id="id1">
<h2>Explanation of the Plot<a class="headerlink" href="#id1" title="Link to this heading"></a></h2>
<p>The plot generated by the above code illustrates several key points:</p>
<ol class="arabic simple">
<li><p>Different Points Have Different Presence/Duration in the STV: Each point’s <strong>temporal presence</strong> is represented by a vertical cylinder (pipe), the <strong>world line</strong> that extends between its start and end dates. Some points have longer durations (pipes) than others.</p></li>
<li><p><strong>World Lines</strong> and <strong>Time Slice</strong> Intersections: Some points have world lines (pipes) that do not intersect the given time slice at 1500 years. These points are not present in the pattern at that specific time, which is visualized by the absence of black dots on the time slice plane at their locations.</p></li>
<li><p><strong>Palimpsest</strong> Representation: When we ignore the time dimension, we are looking at the palimpsest— the overlapping of all points in the spatial domain. This is represented in the plot by the shadows of the points on the ‘floor’ of the plot, showing the aggregated spatial distribution without considering the temporal dimension.</p></li>
</ol>
</section>
</section>
<section id="Pairwise-Distances-and-Clustering-Statistics-in-ChronoCluster">
<h1>Pairwise Distances and Clustering Statistics in ChronoCluster<a class="headerlink" href="#Pairwise-Distances-and-Clustering-Statistics-in-ChronoCluster" title="Link to this heading"></a></h1>
<p>In spatial analysis, pairwise distances are a fundamental measure used to explore clustering structures. By calculating the distances between each pair of points, we can understand how closely points are grouped together. However, temporality and chronological uncertainty complicate these calculations because points may not be contemporaneous and their exact positions in time are uncertain.</p>
<section id="Temporality-and-Chronological-Uncertainty">
<h2>Temporality and Chronological Uncertainty<a class="headerlink" href="#Temporality-and-Chronological-Uncertainty" title="Link to this heading"></a></h2>
<p>Temporality refers to the fact that each point exists in space and time, not just space. Chronological uncertainty refers to the inaccuracies in dating these points. Traditional clustering statistics do not account for these complexities, leading to potentially misleading results. Approach in ChronoCluster</p>
<p>ChronoCluster addresses these issues by:</p>
<ul class="simple">
<li><p>Propagating Uncertainty and Temporality: Using Monte Carlo (MC) simulations to propagate chronological uncertainty.</p></li>
<li><p>Applying Spacetime Thinking: Analyzing points in both spatial and temporal dimensions.</p></li>
<li><p>Using Time Slices: Breaking the analysis into discrete time slices to handle temporality.</p></li>
</ul>
<p>Key Functions:</p>
<ul class="simple">
<li><p>in_probs Function: Precomputes inclusion probabilities based on age models and time slices.</p></li>
<li><p>mc_samples Function: Runs Monte Carlo simulations to generate probable lists of points included in each time slice.</p></li>
<li><p>temporal_pairwise Function: Produces pairwise distances to explore clustering structures over time.</p></li>
<li><p>clustering_heatmap Function: Visualizes temporality and propagates chronological uncertainty into a clustering plot.</p></li>
</ul>
</section>
<section id="Example:-Pairwise-Distances-with-Temporal-and-Chronological-Uncertainty">
<h2>Example: Pairwise Distances with Temporal and Chronological Uncertainty<a class="headerlink" href="#Example:-Pairwise-Distances-with-Temporal-and-Chronological-Uncertainty" title="Link to this heading"></a></h2>
<p>The following example demonstrates how to compute and visualize pairwise distances with temporal and chronological uncertainty.</p>
<section id="Step-1:-Define-Time-Slices">
<h3>Step 1: Define Time Slices<a class="headerlink" href="#Step-1:-Define-Time-Slices" title="Link to this heading"></a></h3>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define the time slices</span>
<span class="n">start_time</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">end_time</span> <span class="o">=</span> <span class="mi">2000</span>
<span class="n">time_interval</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">time_slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">time_interval</span><span class="p">)</span>
<br/></pre></div>
</div>
</div>
</section>
<section id="Step-2:-Precompute-Inclusion-Probabilities">
<h3>Step 2: Precompute Inclusion Probabilities<a class="headerlink" href="#Step-2:-Precompute-Inclusion-Probabilities" title="Link to this heading"></a></h3>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Precompute inclusion probabilities based on age models and time slices</span>
<span class="n">inclusion_probs</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">in_probs</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">time_slices</span><span class="p">)</span>
<br/></pre></div>
</div>
</div>
</section>
<section id="Step-3:-Run-Monte-Carlo-Simulations">
<h3>Step 3: Run Monte Carlo Simulations<a class="headerlink" href="#Step-3:-Run-Monte-Carlo-Simulations" title="Link to this heading"></a></h3>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Run the Monte Carlo simulation to get an ensemble of probable</span>
<span class="c1"># lists of points included in each time slice.</span>
<span class="n">num_iterations</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">simulations</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">mc_samples</span><span class="p">(</span><span class="n">points</span><span class="p">,</span>
                                    <span class="n">time_slices</span><span class="p">,</span>
                                    <span class="n">inclusion_probs</span><span class="p">,</span>
                                    <span class="n">num_iterations</span><span class="o">=</span><span class="n">num_iterations</span><span class="p">)</span>
<br/></pre></div>
</div>
</div>
</section>
<section id="Step-4:-Determine-Maximum-Distance">
<h3>Step 4: Determine Maximum Distance<a class="headerlink" href="#Step-4:-Determine-Maximum-Distance" title="Link to this heading"></a></h3>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get a bounding box for use later and to extract sensible distance limits</span>
<span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">get_box</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
<span class="n">max_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x_max</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y_max</span> <span class="o">-</span> <span class="n">y_min</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
<br/></pre></div>
</div>
</div>
</section>
<section id="Step-5:-Produce-Pairwise-Distances">
<h3>Step 5: Produce Pairwise Distances<a class="headerlink" href="#Step-5:-Produce-Pairwise-Distances" title="Link to this heading"></a></h3>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Produce pairwise distances to explore clustering structure</span>
<span class="n">pairwise_density</span><span class="p">,</span> <span class="n">support</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">temporal_pairwise</span><span class="p">(</span><span class="n">simulations</span><span class="p">,</span>
                                                         <span class="n">time_slices</span><span class="p">,</span>
                                                         <span class="n">bw</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                                         <span class="n">density</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                         <span class="n">max_distance</span><span class="o">=</span><span class="n">max_distance</span><span class="p">)</span>
<br/></pre></div>
</div>
</div>
</section>
<section id="Step-6:-Visualize-Clustering">
<h3>Step 6: Visualize Clustering<a class="headerlink" href="#Step-6:-Visualize-Clustering" title="Link to this heading"></a></h3>
<p>We can visualize the clustering in a couple of ways. First with a heat map and then by randomly sleecting a time slice for plotting.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Visualize clustering with heatmap</span>
<span class="n">clustering_heatmap</span><span class="p">(</span><span class="n">pairwise_density</span><span class="p">,</span>
                   <span class="n">support</span><span class="p">,</span>
                   <span class="n">time_slices</span><span class="p">,</span>
                   <span class="n">result_type</span><span class="o">=</span><span class="s1">&#39;Pairwise Distances&#39;</span><span class="p">)</span>
<br/></pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/tutorialnb_29_0.png" src="_images/tutorialnb_29_0.png" />
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot to see results for a random time slice</span>
<span class="n">rnd_t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_slices</span><span class="p">)))</span>

<span class="c1"># Create a line plot</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

<span class="c1"># Plot K results</span>
<span class="n">axs</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">support</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pairwise_density</span><span class="p">[:,</span> <span class="n">rnd_t</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="n">axs</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Distance&#39;</span><span class="p">)</span>
<span class="n">axs</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Density&#39;</span><span class="p">)</span>
<span class="n">axs</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Pairwise Distance Density for Time Slice </span><span class="si">{</span><span class="n">time_slices</span><span class="p">[</span><span class="n">rnd_t</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">hspace</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/tutorialnb_30_0.png" src="_images/tutorialnb_30_0.png" />
</div>
</div>
</section>
<section id="Interpreting-the-Clustering-Heatmap">
<h3>Interpreting the Clustering Heatmap<a class="headerlink" href="#Interpreting-the-Clustering-Heatmap" title="Link to this heading"></a></h3>
<p>The heatmap generated by the <code class="docutils literal notranslate"><span class="pre">clustering_heatmap</span></code> function provides a visual representation of the temporal clustering structure of the points. Here’s an expanded explanation based on the observed heatmap:</p>
<p><strong>Axes and Color Scale</strong></p>
<ul class="simple">
<li><p>X-Axis (Time Slices): The x-axis represents discrete time slices from 1000 to 2000 years, showing the temporal dimension of the analysis.</p></li>
<li><p>Y-Axis (Distances): The y-axis represents distances between points in the spatial plane (x, y coordinates).</p></li>
<li><p>Color Scale: The color scale represents the mean pairwise distances. The color gradient from purple (low density) to yellow (high density) indicates the relative density of pairwise distances for each time slice.</p></li>
</ul>
<p><strong>Observations</strong></p>
<ol class="arabic simple">
<li><p>Persistent Clustering Over Time:</p>
<ul class="simple">
<li><p>The heatmap shows persistent clustering through time, indicated by the consistent bands of color. This means that there is a stable structure of clusters in the data across the analyzed time period.</p></li>
</ul>
</li>
<li><p>Peaks in Pairwise Distances:</p>
<ul class="simple">
<li><p>There are notable peaks in pairwise distances at around 2 and 14 spatial units. These peaks correspond to the smaller clusters and the distance between clusters, respectively.</p></li>
<li><p>The distance of 2 units represents the average distance between points within the same cluster.</p></li>
<li><p>The distance of 14 units represents the distance between points in different clusters.</p></li>
</ul>
</li>
<li><p>Chronological Uncertainty Propagation:</p>
<ul class="simple">
<li><p>The use of Monte Carlo simulations propagates the chronological uncertainty through the time slices. This is reflected in the smooth transitions and variations in color intensity over time.</p></li>
<li><p>The heatmap marginalizes the propagated chronological uncertainty, averaging the pairwise distances over multiple simulations. But it’s important to note that the map represents only one density estimate—in this case the average across MC simulations—which is marginalizing out the uncertainty and is necessary for vizualization. In reality, there is a whole distribution of these surfaces that reflects the chronological uncertainty and samples of that distribution are contained in the
<code class="docutils literal notranslate"><span class="pre">pairwise_density</span></code> array.</p></li>
</ul>
</li>
<li><p>Clusters and Time Slices:</p>
<ul class="simple">
<li><p>In general with this approach, the presence of distinct clusters could be observed across different time slices. Some clusters might not be present in all time slices due to the temporal uncertainty of the points and their temporality. In the simple example above, there is no meaningful temporality, just chronological uncertainty.</p></li>
<li><p>Points with worldlines that do not intersect a given time slice would not be present in the pattern at that specific time, which would be seen by the absence of corresponding high-density areas in the heatmap for those time slices in cases where the uncertainty was significant and/or there was also temporality in the point pattern.</p></li>
</ul>
</li>
</ol>
</section>
</section>
</section>
<section id="Statistical-Significance-and-Complete-Spatial-Randomness">
<h1>Statistical Significance and Complete Spatial Randomness<a class="headerlink" href="#Statistical-Significance-and-Complete-Spatial-Randomness" title="Link to this heading"></a></h1>
<p>In spatial analysis, evaluating the statistical significance of observed point patterns against a null hypothesis of Complete Spatial Randomness (CSR) is crucial. CSR assumes that points are distributed uniformly and independently across the study area. By comparing the observed point patterns to this null model, we can determine whether the observed clustering or dispersion is statistically significant in the sense that the patterns would be highly unlikely to occurr if the points were randomly
distributed.</p>
<p>ChronoCluster provides functions to perform this comparison and evaluate the statistical significance of point patterns with temporal and chronological uncertainty.</p>
<section id="Example:-Evaluating-Statistical-Significance-Against-CSR">
<h2>Example: Evaluating Statistical Significance Against CSR<a class="headerlink" href="#Example:-Evaluating-Statistical-Significance-Against-CSR" title="Link to this heading"></a></h2>
<p>The following example demonstrates how to calculate the p-values for density differences between observed points and a simulated CSR baseline, and then visualize these p-values using a heatmap. The basic analytical pipeline will involve generating a random point scatter that has the same temporal characteristics of the real (in our case, of course, simulated) data. To do this, ChronoCluster has a function called <code class="docutils literal notranslate"><span class="pre">csr_sample</span></code> that takes a list of <code class="docutils literal notranslate"><span class="pre">Point</span></code> instances and generates a new list
with coordinate values randomized in a way that reflects the CSR assumption. Of course, a ‘study area’ has to be defined and passed in as coordinate limits as well.</p>
<section id="Step-1:-Create-CSR-Data">
<h3>Step 1: Create CSR Data<a class="headerlink" href="#Step-1:-Create-CSR-Data" title="Link to this heading"></a></h3>
<p>We need to create a list of MC simulations as before, but this time with the CSR data. So, we follow the same procedure as above, but replace the <code class="docutils literal notranslate"><span class="pre">points</span></code> list (original data) with a csr sample.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Generate CSR sample</span>
<span class="n">csr_points</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">csr_sample</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">)</span>

<span class="c1"># Get CSR inclusion probabilities (remember these points have the same</span>
<span class="c1"># temporal traits as the first simulated data)</span>
<span class="n">csr_inclusion_probs</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">in_probs</span><span class="p">(</span><span class="n">csr_points</span><span class="p">,</span>
                                          <span class="n">time_slices</span><span class="p">)</span>

<span class="c1"># Get MC iterations for incorporating chronological uncertainty</span>
<span class="n">num_iterations</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">csr_simulations</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">mc_samples</span><span class="p">(</span><span class="n">csr_points</span><span class="p">,</span>
                                        <span class="n">time_slices</span><span class="p">,</span>
                                        <span class="n">csr_inclusion_probs</span><span class="p">,</span>
                                        <span class="n">num_iterations</span> <span class="o">=</span> <span class="n">num_iterations</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Custom styling parameters</span>
<span class="n">style_params</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;start_mean_color&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># Do not plot start mean points</span>
    <span class="s1">&#39;end_mean_color&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="c1"># Do not plot end mean points</span>
    <span class="s1">&#39;mean_point_size&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="s1">&#39;cylinder_color&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">),</span>  <span class="c1"># Dark grey</span>
    <span class="s1">&#39;ppf_limits&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">),</span>  <span class="c1"># Use different ppf limits</span>
    <span class="s1">&#39;shadow_color&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">),</span>  <span class="c1"># grey</span>
    <span class="s1">&#39;shadow_size&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="s1">&#39;time_slice_color&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span>  <span class="c1"># Grey</span>
    <span class="s1">&#39;time_slice_alpha&#39;</span><span class="p">:</span> <span class="mf">0.3</span><span class="p">,</span>
    <span class="s1">&#39;time_slice_point_color&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>  <span class="c1"># Black</span>
<span class="p">}</span>

<span class="c1"># Plot the points using the chrono_plot function with custom styling and a time slice plane</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">chrono_plot</span><span class="p">(</span><span class="n">csr_points</span><span class="p">,</span> <span class="n">style_params</span><span class="o">=</span><span class="n">style_params</span><span class="p">,</span> <span class="n">time_slice</span><span class="o">=</span><span class="mi">1500</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_box_aspect</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">zoom</span><span class="o">=</span><span class="mf">0.85</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/tutorialnb_34_0.png" src="_images/tutorialnb_34_0.png" />
</div>
</div>
</section>
<section id="Step-2.-Calculate-Pairwise-Distance-Density-for-CSR-data">
<h3>Step 2. Calculate Pairwise Distance Density for CSR data<a class="headerlink" href="#Step-2.-Calculate-Pairwise-Distance-Density-for-CSR-data" title="Link to this heading"></a></h3>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Calulate the pairwise distances for the CSR sample</span>
<span class="n">csr_pairwise_density</span><span class="p">,</span> <span class="n">csr_support</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">temporal_pairwise</span><span class="p">(</span><span class="n">csr_simulations</span><span class="p">,</span>
                                                                 <span class="n">time_slices</span><span class="p">,</span>
                                                                 <span class="n">bw</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                                                                 <span class="n">density</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                                 <span class="n">max_distance</span> <span class="o">=</span> <span class="n">max_distance</span><span class="p">)</span>

<span class="c1"># Visualize clustering with heatmap</span>
<span class="n">clustering_heatmap</span><span class="p">(</span><span class="n">csr_pairwise_density</span><span class="p">,</span>
                   <span class="n">csr_support</span><span class="p">,</span>
                   <span class="n">time_slices</span><span class="p">,</span>
                   <span class="n">result_type</span><span class="o">=</span><span class="s1">&#39;Pairwise Distances&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/tutorialnb_36_0.png" src="_images/tutorialnb_36_0.png" />
</div>
</div>
</section>
<section id="Step-3:-Calculate-P-Values-for-Density-Differences">
<h3>Step 3: Calculate P-Values for Density Differences<a class="headerlink" href="#Step-3:-Calculate-P-Values-for-Density-Differences" title="Link to this heading"></a></h3>
<p>We use the p_diff function to calculate the p-values for density differences between the observed points and the simulated CSR baseline for each distance and time slice. Importantly, the distribution we are using for inference is for another random variable, <span class="math notranslate nohighlight">\(p_{diff} = P(observed - csr)\)</span> that reflects the chronological uncertainty in the original data. The <code class="docutils literal notranslate"><span class="pre">p_diff</span></code> function, therefore, takes in the observed statistic array (with shape <code class="docutils literal notranslate"><span class="pre">(distance,</span> <span class="pre">time,</span> <span class="pre">mc_iterations)</span></code>) and a
comparable array for the CSR simulated data and it returns p-values for the differences where the distribution refers to the <code class="docutils literal notranslate"><span class="pre">mc_simulations</span></code> axis in the arrays. So, we are considering the distirbution with respect to chronological uncertainty because samples from the start/end distributions of the points are ultimately used to produce the iterations that are reflected in that axis of the arrays.</p>
<p>The specific calculations for the p-values are as follows, where <code class="docutils literal notranslate"><span class="pre">obs</span></code> is an observed array and <code class="docutils literal notranslate"><span class="pre">csr</span></code> is the CSR baseline:</p>
<ol class="arabic">
<li><p><strong>Mean Calculation</strong>: Calculate the mean difference (<span class="math notranslate nohighlight">\(\mu_{\Delta_{ij}}\)</span>) between the observed and CSR pairwise densities across the iterations (axis=2):</p>
<div class="math notranslate nohighlight">
\[\mu_{\Delta_{ij}} = \frac{1}{N} \sum_{k=1}^{N} (\text{obs}_{ijk} - \text{csr}_{ijk})\]</div>
<p>where <span class="math notranslate nohighlight">\(N\)</span> is the number of iterations, <span class="math notranslate nohighlight">\(i\)</span> indexes the distances, <span class="math notranslate nohighlight">\(j\)</span> indexes the time slices, and <span class="math notranslate nohighlight">\(k\)</span> indexes the iterations.</p>
</li>
<li><p><strong>Standard Deviation Calculation</strong>: Calculate the standard deviation of the differences (<span class="math notranslate nohighlight">\(\sigma_{\Delta_{ij}}\)</span>) across the iterations (axis=2):</p>
<div class="math notranslate nohighlight">
\[\sigma_{\Delta_{ij}} = \sqrt{\frac{1}{N} \sum_{k=1}^{N} \left[(\text{obs}_{ijk} - \text{csr}_{ijk}) - \mu_{\Delta_{ij}}\right]^2}\]</div>
</li>
<li><p><strong>Z-score Calculation</strong>: Calculate the z-scores for each pair of distance and time slice:</p>
<div class="math notranslate nohighlight">
\[z_{\Delta_{ij}} = \frac{\mu_{\Delta_{ij}}}{\sigma_{\Delta_{ij}}}\]</div>
</li>
<li><p><strong>P-value Calculation</strong>: Calculate the p-value using the CDF of the standard normal distribution:</p>
<div class="math notranslate nohighlight">
\[\begin{split}p = \begin{cases}
1 - \Phi(z_{\Delta_{ij}}) &amp; \text{if ``greater''} \\
   \Phi(z_{\Delta_{ij}}) &amp; \text{if ``less''}
\end{cases}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\Phi\)</span> is the CDF of the standard normal distribution.</p>
</li>
</ol>
<p>It’s important to emphasize that the p-values calculated in this way are <strong>not</strong> referring directly to the probability that the difference between the observed and CSR values is greater than zero. They refer to the probability of observing a value as extreme or more extreme under the null hypothesis, which in this case is the standard normal distribution (a normal distribution centred on zero and scaled). As a result, these values are comparable to a standard one-tailed z-test. That said, given
that,</p>
<ol class="arabic simple">
<li><p>the differences are calculated as <span class="math notranslate nohighlight">\(obsserved - csr\)</span>,</p></li>
<li><p>they are standardized, and</p></li>
<li><p>the CDF is used to find the p-value</p></li>
</ol>
<p>low values imply differences that are positive if <span class="math notranslate nohighlight">\(p &lt; 0.5\)</span>. This is because the null (standard normal) is centered on zero, which would have a CDF value of <span class="math notranslate nohighlight">\(0.5\)</span>. Extremely low p-values, say <span class="math notranslate nohighlight">\(p &lt; 0.05\)</span>, would indicate that the probability of observing a more extremely positive difference is low (5% or less, in case of <span class="math notranslate nohighlight">\(p &lt; 0.05\)</span>). So, while the p-values don’t directly relate to the probability that the observed difference is greater than zero, this inequality is implied
because of the way the differences are calculated and the nature of the test design as long as <span class="math notranslate nohighlight">\(p &lt; 0.5\)</span>. Higher p-values suggest a <em>negative difference</em>, which has a specific interpretation for some clustering statisitcs, like Ripley’s K.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[17]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Calculate the p-values for density differences between the observed points and</span>
<span class="c1"># the simulated CSR baseline per distance and temporal slice</span>
<span class="n">p_diff_array</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">p_diff</span><span class="p">(</span><span class="n">pairwise_density</span><span class="p">,</span> <span class="n">csr_pairwise_density</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="Step-4:-Plot-the-Heatmap-of-P-Values">
<h3>Step 4: Plot the Heatmap of P-Values<a class="headerlink" href="#Step-4:-Plot-the-Heatmap-of-P-Values" title="Link to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">pdiff_heatmap</span></code> function is used to visualize the p-values, highlighting the statistical significance of the observed clustering patterns. The interpretation depends on the underlying stastic, which at the moment can be either one of the Ripley functions (K, L, or G) or the pairwise distance density.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[18]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot the heatmap of probabilities</span>
<span class="n">pdiff_heatmap</span><span class="p">(</span><span class="n">p_diff_array</span><span class="p">,</span>
              <span class="n">time_slices</span><span class="p">,</span>
              <span class="n">csr_support</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="_images/tutorialnb_40_0.png" src="_images/tutorialnb_40_0.png" />
</div>
</div>
</section>
<section id="Explanation-of-the-Code">
<h3>Explanation of the Code<a class="headerlink" href="#Explanation-of-the-Code" title="Link to this heading"></a></h3>
<ol class="arabic simple">
<li><p>Calculate P-Values (p_diff Function): - The p_diff function compares the observed clustering statistic to the CSR baseline for that statistic. - It calculates the p-values for the difference in density for each distance and time slice, indicating the probability that the observed pattern is different from CSR in a particular direction indicated by a parameter, <code class="docutils literal notranslate"><span class="pre">condition</span></code> that defaults to ‘greater’.</p></li>
<li><p>Visualize P-Values (pdiff_heatmap Function): - The pdiff_heatmap function plots a heatmap of the p-values, with time slices on the x-axis and distances on the y-axis. - The color gradient represents the p-values, with warmer colors indicating lower (significant) p-values and cooler colors indicating higher (insignificant) p-values.</p></li>
</ol>
</section>
<section id="Interpretation-of-the-Heatmap">
<h3>Interpretation of the Heatmap<a class="headerlink" href="#Interpretation-of-the-Heatmap" title="Link to this heading"></a></h3>
<p>Since we are looking at the difference between the observed pairwise distance distribution and a comparable CSR baseline,</p>
<ol class="arabic simple">
<li><p>Low p-values: - Statistically significant clustering and/or point-distance structure at the indicated distance(s) and time(s) within the STV. - Significant here means the probability of differences as extreme or more extreme than the observed difference is low (with the probability given by the p-value). - In the heatmap, these significant regions are indicated by warmer colours.</p></li>
<li><p>High p-values: - Regions of the pairwise distance distribution (distance(s) and time(s)) that do not differ significantly from CSR within the STV. - In the heatmap, these non-significant regions are indicated by cooler colours.</p></li>
</ol>
</section>
</section>
</section>
<section id="Other-ChronoCluster-Clustering-Statistics">
<h1>Other ChronoCluster Clustering Statistics<a class="headerlink" href="#Other-ChronoCluster-Clustering-Statistics" title="Link to this heading"></a></h1>
<p>Using the same overall pipeline described above, the <code class="docutils literal notranslate"><span class="pre">ChronoCluster</span></code> package provides support for clustering analyses involving three other fundamental cluster statistics:</p>
<ol class="arabic simple">
<li><p>Ripley’s K Function: - Purpose: Measures the number of points within a given distance of each point, adjusted for the overall density of points. - Function: temporal_cluster - Parameters: calc_K=True</p></li>
<li><p>Ripley’s L Function: - Purpose: A linear transformation of Ripley’s K function that stabilizes the variance under CSR. - Function: temporal_cluster - Parameters: calc_L=True</p></li>
<li><p>Pair Correlation Function (Ripley’s G Function): - Purpose: Measures the density of points at a specific distance from a given point, providing insight into the spatial structure at different scales. - Function: temporal_cluster - Parameters: calc_G=True</p></li>
</ol>
<section id="Example-Code-for-Ripley's-K,-L,-and-G-Functions">
<h2>Example Code for Ripley’s K, L, and G Functions<a class="headerlink" href="#Example-Code-for-Ripley's-K,-L,-and-G-Functions" title="Link to this heading"></a></h2>
<p>Below is the example code for calculating Ripley’s K, L, and G functions over time using the ChronoCluster package. This code is for reference and demonstrates how to set up the calculations, but we won’t compute anything in this slide:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define distances for Ripley&#39;s K function</span>
<span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>

<span class="c1"># Calculate K, L, and G functions over time</span>
<span class="n">k_results</span><span class="p">,</span> <span class="n">l_results</span><span class="p">,</span> <span class="n">g_results</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">temporal_cluster</span><span class="p">(</span><span class="n">simulations</span><span class="p">,</span>
                                                              <span class="n">distances</span><span class="p">,</span>
                                                              <span class="n">time_slices</span><span class="p">,</span>
                                                              <span class="n">calc_K</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                              <span class="n">calc_L</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                              <span class="n">calc_G</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Visualize the K function results with a heatmap</span>
<span class="n">clustering_heatmap</span><span class="p">(</span><span class="n">k_results</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">time_slices</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="Explanation">
<h2>Explanation<a class="headerlink" href="#Explanation" title="Link to this heading"></a></h2>
<ol class="arabic simple">
<li><p>Define Distances: - We define a range of distances over which to calculate the clustering statistics, ensuring that the distances cover the relevant scales of spatial interaction.</p></li>
<li><p>Calculate Clustering Statistics: - The temporal_cluster function is used to calculate Ripley’s K, L, and G functions for each time slice and distance. - The parameters calc_K=True, calc_L=True, and calc_G=True indicate that all three statistics should be computed.</p></li>
<li><p>Visualize Results: - The results of the K function are visualized using a heatmap, similar to the approach taken for pairwise distances. - The clustering_heatmap function can be used to plot the results for L and G functions as well, providing insights into the clustering patterns over time and distance.</p></li>
</ol>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="tutorial.html" class="btn btn-neutral float-left" title="Tutorial" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="modules.html" class="btn btn-neutral float-right" title="Modules" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, W. Christopher Carleton.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>